from agents.chains import classification_chain as chain
from langgraph.graph import StateGraph, END, add_messages
from langchain_core.messages import HumanMessage, AIMessage, BaseMessage
from langchain.schema.runnable import RunnableConfig
from langgraph.prebuilt import ToolNode
from langgraph.checkpoint.memory import MemorySaver
from pydantic import BaseModel, Field
from typing import TypedDict, List, Annotated, Literal,Optional, Any, Dict
import logging


from agents.web_agent import web_agent
from agents.sale_agent import sale_agent
from agents.rag_agent import rag_agent
from agents.boss_supervisor import BossOutputFormat
from agents.chains import SupervisorResponse
from agents.boss_supervisor import boss
from agents.customer_care_agent import customer_care_chain
from agents.search_agent import run_web_agent

logging.basicConfig(level = logging.INFO)

memory = MemorySaver()

class BaseState(TypedDict):
    message: Annotated[List[BaseMessage], add_messages]
    categories: List[Dict[Any, Any]] 
    agent_queries: Annotated[dict, "Dict mapping each agent node key to list of queries"]
    boss_state : Annotated[List[Any], "Result of Boss Agent"]
    agent_queries: Annotated[dict, "Dict mapping each agent node key to list of queries"]
    boss_supervisor : Annotated[List[Any], "Boss Agent wheather to verify the result or not."]
    search_tool_result : Annotated[List[Any], "Result generated by search tool agent"]
    rag_agent_result : Annotated[List[Any], "Result generated by rag agent"]
    sales_agent_result : Annotated[List[Any], "Result generated by sales agent"]
    customer_care_agent_result : Annotated[List[Any], "Result generated by customer care agent"]
    event_tool_agent_result : Annotated[str, "List of results by event agent"]
    content_generation_agent_result : Annotated[List[Any], "A list of cotent generation agent results"]
    billing_info_agent_result : Annotated[List[Any], "A List of Billing info agent results"]
    analytics_agent_result : Annotated[List[Any], "A list of Results by Analytics Agent."]
    payment_order_agent_result : Annotated[List[Any], "A List of results by Payment order Agent."]
    feedback_agent_result : Annotated[List[Any], "A List of results by feedback agent."]
    counter : Optional[int]

def categories(state : BaseState):
    # Extract the actual message content for the chai
    logging.info(f"<{"="*40} Supervisor Agent {"="*40}>")
    logging.info(f"State in supervisor node --> {state}")
    message_content = state.get("message", "")
    print(message_content)
    logging.info(f"Supervisor Content {message_content}")
    ans = {"category" : "sales_agent"}
    ans = chain.invoke({"query": message_content}).model_dump()
    logging.info(f"Supervisor : {ans}")
    return {
        "categories": [ans]
    }


def next_node_selector(state : BaseState):
    # Get the categories from state
    cat_obj = state.get("categories", [])
    if not cat_obj:
        return END

    # Take latest HumanMessage content
    cat_content = cat_obj[-1].content if isinstance(cat_obj[-1], BaseMessage) else cat_obj[-1]
    if not cat_content:
        return END

    # Parse JSON string to dict if needed
    if isinstance(cat_content, str):
        import json
        cat_content = json.loads(cat_content)

    subtasks = cat_content.get("subtasks", [])
    logging.info(f"Subtasks to select the node : {subtasks}")
    agent_queries = {}

    agent_node_keys = []
    for subtask in subtasks:
        agent_name = subtask.get("agent_name")
        queries = subtask.get("query", [])

        if agent_name == "search_tool_agent":
            node_key = "search_tool_agent"
        elif agent_name == "event_tool_agent":
            return "event_tool_agent"
        elif agent_name == "content_generation_agent":
            node_key = "content_generation_agent"
        elif agent_name == "rag_agent":
            node_key = "rag_agent"
        elif agent_name == "sales_agent":
            node_key = "sale_agent"
        elif agent_name == "billing_info_agent":
            node_key = "billing_info_agent"
        elif agent_name == "payment_order_agent":
            node_key = "payment_order_agent"
        elif agent_name == "feedback_agent":
            node_key = "feedback_agent"
        elif agent_name == "analytics_agent":
            node_key = "analytics_agent"
        elif agent_name=="customer_care_agent":
            node_key = "customer_care_agent"
        else:
            return END
        agent_queries[node_key] = queries
        agent_node_keys.append(node_key)
    state["agent_queries"] = agent_queries

    if not agent_node_keys:
        return END

    logging.info(f"Parallel agents selected: {agent_node_keys}")
    logging.info(f"Node keys: {agent_node_keys} types: {[type(k) for k in agent_node_keys]}")
    return {
        "agent_queries": agent_queries,
        "__next__": agent_node_keys
    }


def search_tool_agent(state : BaseState):
    logging.info(f"<{"="*40} Search Agent {"="*40}>")
    queries = state.get("agent_queries", {}).get("search_tool_agent", [])
    # combined_query = " ".join(queries)
    logging.info(f"Search tool queries: {queries}")
    ans = []
    
    for query in queries:
        result = run_web_agent(query=query)
        logging.info(f"Search result: {ans}")
        ans.append(result)

    logging.info(f"Search Agent Result : {ans}")
    return {
        "search_tool_result" : ans
    }


def event_tool_agent(state : BaseState):
    return {
        "event_tool_agent_result": ["event_agent called"]
    }


def content_generation_agent(state : BaseState):
    return {
        "content_generation_agent_result": ["content-generated"]
    }


def rag_agent_(state : BaseState):
    logging.info(f"<{"="*40} RAG Agent {"="*40}>")
    queries = state.get("agent_queries", {}).get("rag_agent", [])
    # combined_query = " ".join(queries)
    logging.info(f"RAG Agent queries: {queries}")
    ans = []
    
    for query in queries:
        result = rag_agent.invoke({"input" : query})
        logging.info(f"Search result: {ans}")
        ans.append(result)
    
    logging.info(f"Rag Agent Result : {ans}")
    return {
        "rag_agent_result" : ans
    }

def sale_agent_(state : BaseState):
    queries = state.get("agent_queries", {}).get("sale_agent", [])
    logging.info(f"<{"="*40} Sales Agent {"="*40}>")
    logging.info(f"Sale Agent queries: {queries}")
    ans = []
    
    for query in queries:
        result = sale_agent.invoke(query)
        logging.info(f"Search result: {ans}")
        ans.append(result)
    
    logging.info(f"Sales Agent Result : ")
    return {
        "sales_agent_result" : ans
    }

def customer_care(state : BaseState):
    logging.info(f"<{"="*40} Customer Care Agent {"="*40}>")
    queries = state.get("agent_queries", {}).get("customer_care_agent", [])
    logging.info(f"Customer Care queries: {queries}")
    ans = []
    
    for query in queries:
        result = customer_care_chain.invoke(query)
        logging.info(f"Search result: {ans}")
        ans.append(result)
    
    return {
        "customer_care_agent_result" : ans
    }

def billing_info_agent(state : BaseState):
    return {
        "billing_info_agent_result": ["billing_info_agent called"]
    }


def payment_order_agent(state : BaseState):
    return {
        "payment_order_agent_result": ["payment_order_agent called"]
    }


def feedback_agent(state : BaseState):
    return {
        "feedback_agent_result": ["feedback_agent called"]
    }


def analytics_agent(state : BaseState):
    return {
        "analytics_agent_result": ["analytics_agent called"]
    }


def conversation_agent(state):
    return {
         "conversation_agent_result": ["conversation approved"]
    }

def boss_supervisor(state : BaseState):
    logging.info(f"<{"="*40} Boss Agent {"="*40}>")
    sales_result = state.get("sales_agent_result")
    rag_result = state.get("rag_agent_result")
    search_result = state.get("search_tool_result")
    customer_result = state.get("customer_care_agent_result")

    # You can aggregate or review as needed
    summary = "Result By Different Agents\n"
    if sales_result:
        summary += f"- Sales Agent: {sales_result}\n"
    if rag_result:
        summary += f"- RAG Agent: {rag_result}\n"
    if search_result:
        summary += f"- Search tool Agent: {search_result}\n"
    if customer_result:
        summary += f"- Customer Care Agent: {customer_result}\n"

    logging.info(f"Boss final review summary: {summary}")
    counter = state.get("counter", 0)
    categories = state.get("categories", [])
    message = state.get("message", "")

    force_approve = "False" if counter < 2 else "True"

    invoke_payload = {
        "force_approve": force_approve,
        "context": categories,
        "agent_response": summary,
        "query": message
    }
    ans = boss.invoke(invoke_payload).model_dump()
    logging.info(f"Answer by Boss Supervisor : {ans}")
    return {
        "boss_state" : [ans],
        "counter" : counter + 1
    }


def is_approved(state: BaseState):
    response = state.get("boss_state", {"approved" : True})[-1]
    counter = state.get("counter", 0)
    if counter is None:
        counter = 0

    if response.get("approved"):
        return END
    else:
        return "supervisor"

# Create the graph
graph = StateGraph(BaseState)

# Add nodes
graph.add_node("supervisor", categories)
graph.add_node("next_node_selector", next_node_selector)
graph.add_node("search_tool_agent", search_tool_agent)
graph.add_node("event_tool_agent", event_tool_agent)
graph.add_node("content_generation_agent", content_generation_agent)
graph.add_node("rag_agent", rag_agent_)
graph.add_node("sale_agent", sale_agent_)
graph.add_node("billing_info_agent", billing_info_agent)
graph.add_node("payment_order_agent", payment_order_agent)
graph.add_node("feedback_agent", feedback_agent)
graph.add_node("analytics_agent", analytics_agent)
graph.add_node("customer_care_agent", customer_care)
graph.add_node("boss_supervisor", boss_supervisor)

# Set entry point
graph.set_entry_point("supervisor")

# Add conditional edges - the function name should match a function that returns the next node
# graph.add_conditional_edges(
#     "supervisor",
#     next_node_selector,
#     {
#         "search_tool_agent": "search_tool_agent",
#         "event_tool_agent": "event_tool_agent", 
#         "content_generation_agent": "content_generation_agent",
#         "rag_agent": "rag_agent",
#         "sale_agent": "sale_agent",
#         "billing_info_agent": "billing_info_agent",
#         "payment_order_agent": "payment_order_agent",
#         "feedback_agent": "feedback_agent",
#         "analytics_agent": "analytics_agent",
#         "customer_care_agent" : "customer_care_agent",
#         END : END
#     }
# )
graph.add_edge("supervisor", "next_node_selector")
graph.add_edge("next_node_selector" , "search_tool_agent")
graph.add_edge("next_node_selector","event_tool_agent" )
graph.add_edge("next_node_selector","content_generation_agent" )
graph.add_edge("next_node_selector","rag_agent" )
graph.add_edge("next_node_selector","sale_agent" )
graph.add_edge("next_node_selector","billing_info_agent" )
graph.add_edge("next_node_selector","payment_order_agent" )
graph.add_edge("next_node_selector","feedback_agent")
graph.add_edge("next_node_selector","analytics_agent")
graph.add_edge("next_node_selector","customer_care_agent")
graph.add_edge("next_node_selector",END)

# "search_tool_agent",
#         : "event_tool_agent", 
#         "content_generation_agent": "content_generation_agent",
#         "rag_agent": "rag_agent",
#         "sale_agent": "sale_agent",
#         "billing_info_agent": "billing_info_agent",
#         "payment_order_agent": "payment_order_agent",
#         "feedback_agent": "feedback_agent",
#         "analytics_agent": "analytics_agent",
#         "customer_care_agent" : "customer_care_agent",
#         END : END
#     }
# )

# Add edges to END from each agent
graph.add_edge("search_tool_agent", "boss_supervisor")
graph.add_edge("event_tool_agent", "boss_supervisor")
graph.add_edge("content_generation_agent", "boss_supervisor")
graph.add_edge("rag_agent", "boss_supervisor")
graph.add_edge("sale_agent", "boss_supervisor")
graph.add_edge("billing_info_agent", "boss_supervisor")
graph.add_edge("payment_order_agent", "boss_supervisor")
graph.add_edge("feedback_agent", "boss_supervisor")
graph.add_edge("analytics_agent", "boss_supervisor")
graph.add_edge("customer_care_agent", "boss_supervisor")

graph.add_conditional_edges("boss_supervisor", is_approved,
                            {
                                "supervisor" : "supervisor",
                                END : END
                            })

# graph.add_edge("boss_supervisor", END)
# Compile the graph
final_agent = graph.compile(checkpointer=memory)


# Example usage:
if __name__ == "__main__":
    # Test the graph
    initial_state = {
        "message": [],
        "categories": []
    }

    while True:
        user = input("Enter your Questions : ")
        # config = {"configurable": {
        #     "thread_id": "1"
        # }}
        config = RunnableConfig(
            configurable={
                "thread_id" : "1"
            }
        )
        initial_state["message"].append(user)
        result = final_agent.invoke(initial_state, config=config)
        print(result)
        # for msg in result["message"]:
        #     initial_state["message"].append(msg.content)
        # initial_state["message"].append(result["message"][-2].content)
        # for msg in result["categories"]:
        #     initial_state["categories"].append(msg.content)
        
        print("Final result:", result)
        print(initial_state)