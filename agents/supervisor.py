from agents.chains import classification_chain as chain
from langgraph.graph import StateGraph, END, add_messages
from langchain_core.messages import HumanMessage, AIMessage
from langchain.schema.runnable import RunnableConfig
from langgraph.prebuilt import ToolNode
from langgraph.checkpoint.memory import MemorySaver
from pydantic import BaseModel, Field
from typing import TypedDict, List, Annotated, Literal,Optional
import logging


from agents.web_agent import web_agent
from agents.sale_agent import sale_agent
from agents.rag_agent import rag_agent

logging.basicConfig(level = logging.INFO)

memory = MemorySaver()

class BaseState(TypedDict):
    message: Annotated[List[str], add_messages]
    categories: Annotated[List[str], add_messages]


def categories(state):
    # Extract the actual message content for the chain
    logging.info(f"State in supervisor node --> {state}")
    message_content = state.get("message", "")[-1]
    print()
    if isinstance(message_content, list):
        message_content = message_content[-1] if message_content else ""
    logging.info(f"Supervisor Content {message_content}")
    ans = ""
    try:
        ans = chain.invoke({"query": message_content}).model_dump()
        logging.info(f"response of supervisor {ans}")
        logging.info(f"Answer Category : {ans['category']}")
    except Exception as e:
        logging.error(f"Happening in supervisor {e}")
    return {
        "categories": ans['category']
    }


def next_node_selector(state):
    # Get the categories from state
    cat_list = state.get("categories", [])
    if not cat_list:
        return END
    
    # Get the latest category
    cat = cat_list[-1] if isinstance(cat_list, list) else cat_list
    cat = cat.model_dump()
    cat = cat['content']
    logging.info(f"Category found is this : {cat}")
    if cat == "search_tool_agent":
        return "search_tool_agent"
    elif cat == "event_tool_agent":
        return "event_tool_agent"
    elif cat == "content_generation_agent":
        return "content_generation_agent"
    elif cat == "rag_agent":
        return "rag_agent"
    elif cat == "sales_agent":
        return "sale_agent"
    elif cat == "billing_info_agent":
        return "billing_info_agent"
    elif cat == "payment_order_agent":
        return "payment_order_agent"
    elif cat == "feedback_agent":
        return "feedback_agent"
    elif cat == "analytics_agent":
        return "analytics_agent"
    elif cat=="customer_care_agent":
        return "customer_care_agent"
    else:
        logging.info("End is being called")
        return END


def search_tool_agent(state):
    message_content = state.get("message", "")[-1]
    if isinstance(message_content, list):
        message_content = message_content[-1] if message_content else ""
    logging.info(f"Search query: {message_content}")
    try:
        ans = web_agent({"query": message_content})
        logging.info(f"Search result: {ans}")
        return {
            "message": [ans["output"] if isinstance(ans, dict) else str(ans)]
        }
    except Exception as e:
        logging.error(f"Error in search_tool_agent: {e}")
        return {
            "message": [f"Error occurred during search: {str(e)}"] 
        }


def event_tool_agent(state):
    return {
        "message": ["event_agent called"]
    }


def content_generation_agent(state):
    return {
        "message": ["content-generated"]
    }


def rag_agent_(state):
    message_content = state.get("message", "")[-1]
    result = rag_agent.invoke({"query" : message_content})
    return {
        "message": result['output']
    }


def sale_agent_(state):
    message_content = state.get("message", "")[-1]
    result = sale_agent.invoke(message_content)
    logging.info(f"result generated by sales : {result}")
    return {
        "message": result['output']
    }


def billing_info_agent(state):
    return {
        "message": ["billing_info_agent called"]
    }


def payment_order_agent(state):
    return {
        "message": ["payment_order_agent called"]
    }


def feedback_agent(state):
    return {
        "message": ["feedback_agent called"]
    }


def analytics_agent(state):
    return {
        "message": ["analytics_agent called"]
    }


def conversation_agent(state):
    return {
         "message": ["conversation approved"]
    }

def boss_supervisor(state):
    return {
         "message": ["boss supervisor approved"]
    }

# Create the graph
graph = StateGraph(BaseState)

# Add nodes
graph.add_node("supervisor", categories)
graph.add_node("search_tool_agent", search_tool_agent)
graph.add_node("event_tool_agent", event_tool_agent)
graph.add_node("content_generation_agent", content_generation_agent)
graph.add_node("rag_agent", rag_agent_)
graph.add_node("sale_agent", sale_agent_)
graph.add_node("billing_info_agent", billing_info_agent)
graph.add_node("payment_order_agent", payment_order_agent)
graph.add_node("feedback_agent", feedback_agent)
graph.add_node("analytics_agent", analytics_agent)
graph.add_node("customer_care_agent", conversation_agent)
graph.add_node("boss_supervisor", boss_supervisor)

# Set entry point
graph.set_entry_point("supervisor")

# Add conditional edges - the function name should match a function that returns the next node
graph.add_conditional_edges(
    "supervisor",
    next_node_selector,
    {
        "search_tool_agent": "search_tool_agent",
        "event_tool_agent": "event_tool_agent", 
        "content_generation_agent": "content_generation_agent",
        "rag_agent": "rag_agent",
        "sale_agent": "sale_agent",
        "billing_info_agent": "billing_info_agent",
        "payment_order_agent": "payment_order_agent",
        "feedback_agent": "feedback_agent",
        "analytics_agent": "analytics_agent",
        "customer_care_agent" : "customer_care_agent",
        END : END
    }
)

# Add edges to END from each agent
graph.add_edge("search_tool_agent", "boss_supervisor")
graph.add_edge("event_tool_agent", "boss_supervisor")
graph.add_edge("content_generation_agent", "boss_supervisor")
graph.add_edge("rag_agent", "boss_supervisor")
graph.add_edge("sale_agent", "boss_supervisor")
graph.add_edge("billing_info_agent", "boss_supervisor")
graph.add_edge("payment_order_agent", "boss_supervisor")
graph.add_edge("feedback_agent", "boss_supervisor")
graph.add_edge("analytics_agent", "boss_supervisor")
graph.add_edge("customer_care_agent", "boss_supervisor")

graph.add_edge("boss_supervisor", END)
# Compile the graph
final_agent = graph.compile(checkpointer=memory)


# Example usage:
if __name__ == "__main__":
    # Test the graph
    initial_state = {
        "message": [],
        "categories": []
    }

    while True:
        user = input("Enter your Questions : ")
        # config = {"configurable": {
        #     "thread_id": "1"
        # }}
        config = RunnableConfig(
            configurable={
                "thread_id" : "1"
            }
        )
        initial_state["message"].append(user)
        result = final_agent.invoke(initial_state, config=config)
        print(result)
        # for msg in result["message"]:
        #     initial_state["message"].append(msg.content)
        initial_state["message"].append(result["message"][-2].content)
        for msg in result["categories"]:
            initial_state["categories"].append(msg.content)
        
        print("Final result:", result["categories"][-1].content)
        print(initial_state)