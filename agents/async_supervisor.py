from agents.chains import classification_chain as chain
from langgraph.graph import StateGraph, END, add_messages
from langchain_core.messages import HumanMessage, AIMessage, BaseMessage
from langchain.schema.runnable import RunnableConfig
from langgraph.prebuilt import ToolNode
from langgraph.checkpoint.memory import MemorySaver
from pydantic import BaseModel, Field
from typing import TypedDict, List, Annotated, Literal, Optional, Any, Dict
import logging
import asyncio
from contextlib import asynccontextmanager
import time
import json

# Import agents
from agents.web_agent import web_agent
from agents.sale_agent import sale_agent
from agents.rag_agent import rag_agent
from agents.boss_supervisor import BossOutputFormat
from agents.chains import SupervisorResponse
from agents.boss_supervisor import boss
from agents.customer_care_agent import customer_care_chain
from agents.search_agent import run_web_agent

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class BaseState(TypedDict):
    message: Annotated[List[BaseMessage], add_messages]
    categories: List[Dict[Any, Any]]
    agent_queries: Annotated[dict, "Dict mapping each agent node key to list of queries"]
    boss_state: Annotated[List[Any], "Result of Boss Agent"]
    boss_supervisor: Annotated[List[Any], "Boss Agent whether to verify the result or not."]
    search_tool_result: Annotated[List[Any], "Result generated by search tool agent"]
    rag_agent_result: Annotated[List[Any], "Result generated by rag agent"]
    sales_agent_result: Annotated[List[Any], "Result generated by sales agent"]
    customer_care_agent_result: Annotated[List[Any], "Result generated by customer care agent"]
    event_tool_agent_result: Annotated[str, "List of results by event agent"]
    content_generation_agent_result: Annotated[List[Any], "A list of content generation agent results"]
    billing_info_agent_result: Annotated[List[Any], "A List of Billing info agent results"]
    analytics_agent_result: Annotated[List[Any], "A list of Results by Analytics Agent."]
    payment_order_agent_result: Annotated[List[Any], "A List of results by Payment order Agent."]
    feedback_agent_result: Annotated[List[Any], "A List of results by feedback agent."]
    counter: Optional[int]

class SupervisorService:
    """Service class to handle supervisor operations"""

    def __init__(self):
        self.max_counter = 3

    def get_current_message(self, state: BaseState) -> BaseMessage:
        """Safely extract current message from state"""
        messages = state.get("message", [])
        if not messages:
            raise ValueError("No messages in state")
        return messages[-1]

    def get_previous_messages(self, state: BaseState) -> List[BaseMessage]:
        """Get previous messages excluding current"""
        messages = state.get("message", [])
        return messages[:-1] if len(messages) > 1 else []

# Initialize service
supervisor_service = SupervisorService()

async def categories(state: BaseState):
    """Categorize incoming messages using classification chain"""
    logger.info(f"<{'='*40} Supervisor Agent {'='*40}>")
    logger.info(f"State in supervisor node --> {state}")

    try:
        current_message = supervisor_service.get_current_message(state)
        previous_messages = supervisor_service.get_previous_messages(state)

        logger.info(f"Current Query: {current_message}")
        logger.info(f"Previous messages count: {len(previous_messages)}")

        # Invoke classification chain directly
        result = await chain.ainvoke({"query": current_message, "prev": previous_messages})

        # Handle both dict and model dump responses
        if hasattr(result, 'model_dump'):
            ans = result.model_dump()
        else:
            ans = result

        logger.info(f"Supervisor classification result: {ans}")

        return {
            "categories": [ans]
        }

    except Exception as e:
        logger.error(f"Error in categories function: {str(e)}")
        # Return default fallback
        return {
            "categories": [{"category": "customer_care_agent", "subtasks": []}]
        }

async def next_node_selector(state: BaseState):
    """Select next nodes based on categorization results"""
    logger.info(f"<{'='*40} Node Selector {'='*40}>")

    try:
        cat_obj = state.get("categories", [])
        if not cat_obj:
            logger.warning("No categories found, ending")
            return END

        # Get the latest category result
        cat_content = cat_obj[-1] if cat_obj else {}

        # Handle BaseMessage objects
        if isinstance(cat_content, BaseMessage):
            cat_content = json.loads(cat_content.content)
        elif isinstance(cat_content, str):
            cat_content = json.loads(cat_content)

        subtasks = cat_content.get("subtasks", [])
        logger.info(f"Subtasks to select the node: {subtasks}")

        # Map agent names to node keys
        agent_mapping = {
            "search_tool_agent": "search_tool_agent",
            "event_tool_agent": "event_tool_agent",
            "content_generation_agent": "content_generation_agent",
            "rag_agent": "rag_agent",
            "sales_agent": "sale_agent",
            "billing_info_agent": "billing_info_agent",
            "payment_order_agent": "payment_order_agent",
            "feedback_agent": "feedback_agent",
            "analytics_agent": "analytics_agent",
            "customer_care_agent": "customer_care_agent"
        }

        agent_queries = {}
        agent_node_keys = []

        for subtask in subtasks:
            agent_name = subtask.get("agent_name")
            queries = subtask.get("query", [])

            # Ensure queries is a list
            if isinstance(queries, str):
                queries = [queries]

            if agent_name in agent_mapping:
                node_key = agent_mapping[agent_name]
                agent_queries[node_key] = queries
                agent_node_keys.append(node_key)
                logger.info(f"Added agent {agent_name} -> {node_key} with queries: {queries}")

        if not agent_node_keys:
            logger.warning("No valid agent nodes selected, ending")
            return END

        logger.info(f"Selected agent nodes: {agent_node_keys}")

        return {
            "agent_queries": agent_queries
        }

    except Exception as e:
        logger.error(f"Error in next_node_selector: {str(e)}")
        return END

async def search_tool_agent(state: BaseState):
    """Execute search tool agent"""
    logger.info(f"<{'='*40} Search Agent {'='*40}>")

    try:
        queries = state.get("agent_queries", {}).get("search_tool_agent", [])
        logger.info(f"Search tool queries: {queries}")

        results = []
        for query in queries:
            start_time = time.time()
            result = await web_agent.ainvoke({"input": query})
            execution_time = time.time() - start_time
            logger.info(f"Search Agent executed successfully in {execution_time:.2f}s")
            results.append(result)

        logger.info(f"Search Agent Results: {len(results)} results")

        return {
            "search_tool_result": results
        }

    except Exception as e:
        logger.error(f"Search agent execution failed: {str(e)}")
        return {
            "search_tool_result": [{"error": str(e)}]
        }

async def event_tool_agent(state: BaseState):
    """Execute event tool agent"""
    logger.info(f"<{'='*40} Event Agent {'='*40}>")

    return {
        "event_tool_agent_result": ["event_agent executed"]
    }

async def content_generation_agent(state: BaseState):
    """Execute content generation agent"""
    logger.info(f"<{'='*40} Content Generation Agent {'='*40}>")

    return {
        "content_generation_agent_result": ["content generated"]
    }

async def rag_agent_(state: BaseState):
    """Execute RAG agent"""
    logger.info(f"<{'='*40} RAG Agent {'='*40}>")

    try:
        queries = state.get("agent_queries", {}).get("rag_agent", [])
        logger.info(f"RAG Agent queries: {queries}")

        results = []
        for query in queries:
            start_time = time.time()
            result = await rag_agent.ainvoke({"input": query})
            execution_time = time.time() - start_time
            logger.info(f"RAG Agent executed successfully in {execution_time:.2f}s")
            results.append(result)

        logger.info(f"RAG Agent Results: {len(results)} results")

        return {
            "rag_agent_result": results
        }

    except Exception as e:
        logger.error(f"RAG agent execution failed: {str(e)}")
        return {
            "rag_agent_result": [{"error": str(e)}]
        }

async def sale_agent_(state: BaseState):
    """Execute sales agent"""
    logger.info(f"<{'='*40} Sales Agent {'='*40}>")

    try:
        queries = state.get("agent_queries", {}).get("sale_agent", [])
        logger.info(f"Sales Agent queries: {queries}")

        results = []
        for query in queries:
            start_time = time.time()
            result = await sale_agent.ainvoke(query)
            execution_time = time.time() - start_time
            logger.info(f"Sales Agent executed successfully in {execution_time:.2f}s")
            results.append(result)

        logger.info(f"Sales Agent Results: {len(results)} results")

        return {
            "sales_agent_result": results
        }

    except Exception as e:
        logger.error(f"Sales agent execution failed: {str(e)}")
        return {
            "sales_agent_result": [{"error": str(e)}]
        }

async def customer_care(state: BaseState):
    """Execute customer care agent"""
    logger.info(f"<{'='*40} Customer Care Agent {'='*40}>")

    try:
        queries = state.get("agent_queries", {}).get("customer_care_agent", [])
        logger.info(f"Customer Care queries: {queries}")

        results = []
        for query in queries:
            start_time = time.time()
            result = await customer_care_chain.ainvoke(query)
            execution_time = time.time() - start_time
            logger.info(f"Customer Care Agent executed successfully in {execution_time:.2f}s")
            results.append(result)

        logger.info(f"Customer Care Results: {len(results)} results")

        return {
            "customer_care_agent_result": results
        }

    except Exception as e:
        logger.error(f"Customer care agent execution failed: {str(e)}")
        return {
            "customer_care_agent_result": [{"error": str(e)}]
        }

async def billing_info_agent(state: BaseState):
    """Execute billing info agent"""
    logger.info(f"<{'='*40} Billing Info Agent {'='*40}>")

    return {
        "billing_info_agent_result": ["billing_info_agent executed"]
    }

async def payment_order_agent(state: BaseState):
    """Execute payment order agent"""
    logger.info(f"<{'='*40} Payment Order Agent {'='*40}>")

    return {
        "payment_order_agent_result": ["payment_order_agent executed"]
    }

async def feedback_agent(state: BaseState):
    """Execute feedback agent"""
    logger.info(f"<{'='*40} Feedback Agent {'='*40}>")

    return {
        "feedback_agent_result": ["feedback_agent executed"]
    }

async def analytics_agent(state: BaseState):
    """Execute analytics agent"""
    logger.info(f"<{'='*40} Analytics Agent {'='*40}>")

    return {
        "analytics_agent_result": ["analytics_agent executed"]
    }

async def boss_supervisor(state: BaseState):
    """Execute boss supervisor for final review"""
    logger.info(f"<{'='*40} Boss Agent {'='*40}>")

    try:
        # Collect results from all agents
        sales_result = state.get("sales_agent_result")
        rag_result = state.get("rag_agent_result")
        search_result = state.get("search_tool_result")
        customer_result = state.get("customer_care_agent_result")

        # Build summary
        summary = "Results from different agents:\n"
        if sales_result:
            summary += f"- Sales Agent: {sales_result}\n"
        if rag_result:
            summary += f"- RAG Agent: {rag_result}\n"
        if search_result:
            summary += f"- Search Agent: {search_result}\n"
        if customer_result:
            summary += f"- Customer Care Agent: {customer_result}\n"

        logger.info(f"Boss supervisor summary: {summary}")

        # Get current state
        counter = state.get("counter", 0)
        categories = state.get("categories", [])
        messages = state.get("message", [])

        if not messages:
            raise ValueError("No messages found for boss supervisor")

        current_message = messages[-1]
        previous_messages = messages[:-1]

        # Determine if we should force approval
        force_approve = "True" if counter >= supervisor_service.max_counter else "False"

        # Prepare payload for boss agent
        invoke_payload = {
            "force_approve": force_approve,
            "context": categories,
            "agent_response": summary,
            "query": current_message,
            "prev": previous_messages
        }

        # Invoke boss agent directly
        start_time = time.time()
        result = await boss.ainvoke(invoke_payload)
        execution_time = time.time() - start_time
        logger.info(f"Boss Supervisor executed successfully in {execution_time:.2f}s")

        # Handle response
        if hasattr(result, 'model_dump'):
            ans = result.model_dump()
        else:
            ans = result

        logger.info(f"Boss supervisor result: {ans}")

        return {
            "boss_state": [ans],
            "counter": counter + 1
        }

    except Exception as e:
        logger.error(f"Error in boss_supervisor: {str(e)}")
        # Return default approval to prevent infinite loops
        return {
            "boss_state": [{"approved": True, "ans": f"Error in processing: {str(e)}"}],
            "counter": supervisor_service.max_counter
        }

def is_approved(state: BaseState):
    """Check if boss supervisor approved the result"""
    try:
        boss_state = state.get("boss_state", [])
        counter = state.get("counter", 0)

        if not boss_state:
            logger.warning("No boss state found, ending")
            return END
        return END
        #latest_response = boss_state[-1]

        # Force end if counter exceeded
        #if counter >= supervisor_service.max_counter:
            #logger.info(f"Counter exceeded max ({supervisor_service.max_counter}), ending")
            #return END

        # Check approval
        #if latest_response.get("approved", False):
            #logger.info("Boss supervisor approved, ending")
            #return END
        #else:
            #logger.info("Boss supervisor not approved, retrying")
            #return "supervisor"

    except Exception as e:
        logger.error(f"Error in is_approved: {str(e)}")
        return END

# Create the graph
def create_graph():
    """Factory function to create the supervisor graph"""
    graph = StateGraph(BaseState)

    # Add nodes
    graph.add_node("supervisor", categories)
    graph.add_node("next_node_selector", next_node_selector)
    graph.add_node("search_tool_agent", search_tool_agent)
    graph.add_node("event_tool_agent", event_tool_agent)
    graph.add_node("content_generation_agent", content_generation_agent)
    graph.add_node("rag_agent", rag_agent_)
    graph.add_node("sale_agent", sale_agent_)
    graph.add_node("billing_info_agent", billing_info_agent)
    graph.add_node("payment_order_agent", payment_order_agent)
    graph.add_node("feedback_agent", feedback_agent)
    graph.add_node("analytics_agent", analytics_agent)
    graph.add_node("customer_care_agent", customer_care)
    graph.add_node("boss_supervisor", boss_supervisor)

    # Set entry point
    graph.set_entry_point("supervisor")

    # Add edges
    graph.add_edge("supervisor", "next_node_selector")

    # Parallel execution edges from node selector
    graph.add_edge("next_node_selector", "search_tool_agent")
    graph.add_edge("next_node_selector", "event_tool_agent")
    graph.add_edge("next_node_selector", "content_generation_agent")
    graph.add_edge("next_node_selector", "rag_agent")
    graph.add_edge("next_node_selector", "sale_agent")
    graph.add_edge("next_node_selector", "billing_info_agent")
    graph.add_edge("next_node_selector", "payment_order_agent")
    graph.add_edge("next_node_selector", "feedback_agent")
    graph.add_edge("next_node_selector", "analytics_agent")
    graph.add_edge("next_node_selector", "customer_care_agent")
    graph.add_edge("next_node_selector", END)

    # All agents flow to boss supervisor
    graph.add_edge("search_tool_agent", "boss_supervisor")
    graph.add_edge("event_tool_agent", "boss_supervisor")
    graph.add_edge("content_generation_agent", "boss_supervisor")
    graph.add_edge("rag_agent", "boss_supervisor")
    graph.add_edge("sale_agent", "boss_supervisor")
    graph.add_edge("billing_info_agent", "boss_supervisor")
    graph.add_edge("payment_order_agent", "boss_supervisor")
    graph.add_edge("feedback_agent", "boss_supervisor")
    graph.add_edge("analytics_agent", "boss_supervisor")
    graph.add_edge("customer_care_agent", "boss_supervisor")

    # Conditional edge from boss supervisor
    graph.add_conditional_edges(
        "boss_supervisor",
        is_approved,
        {
            "supervisor": "supervisor",
            END: END
        }
    )

    return graph

# Create graph instance
graph = create_graph()

# Example usage for testing
async def test_supervisor():
    """Test function for the supervisor system"""
    memory = MemorySaver()
    agent = graph.compile(checkpointer=memory)

    initial_state = {
        "message": [HumanMessage(content="What are your sales offerings?")],
        "categories": [],
        "counter": 0
    }

    config = RunnableConfig(
        configurable={
            "thread_id": "test_thread_1"
        }
    )

    try:
        result = await agent.ainvoke(initial_state, config=config)
        print("Final result:", result)
        return result
    except Exception as e:
        logger.error(f"Test failed: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(test_supervisor())
